/*
// Based off of the Java implementation here: https://www.baeldung.com/java-dijkstra

// Add cost and prec/prev to Node (?)
// Have two different implementations -- one with DoubleTable and one with cost

// HELPER METHODS

// Find the unsettled node the shortest distance away
Node getCheapestNode(NodeList unsettledNodes) {
    Node cheapestNode = null;
    double cheapestCost = infinity;
    for (Node n in unsettledNodes) {
        if (n.cost() < cheapestCost) {
            cheapestCost = n.cost();
            cheapestNode = n;
        }
    }
    return cheapestNode;
}

NodeList getShortestPath(Node source, Node goal) {
    NodeList path = createNodeList();
    Node current = goal;
    while (current) {
        path.prepend(current);
        current = current.prec();
    }
    return path;
}

Graph dijkstra(Graph g, Node source, Node goal) {
    source.updateCost(0);

    NodeList settledNodes = createNodeList(); // nodes with known cheapest cost
    NodeList unsettledNodes = createNodeList(); // frontier nodes with unknown cheapest cost
    unsettledNodes.append(source);

    while (!unsettledNodes.empty()) {
        Node currentNode = getCheapestNode(unsettledNodes);
        unsettledNodes.remove(currentNode);

        // Iterate through neighbors to find minimum distance and add them to unsettled
        for (Node adjacentNode in currentNode.neighbors()) {
            if (!settledNodes.includes(adjacentNode)) {
                double edgeWeight = currentNode.getEdge(adjacentNode).weight();
                // If it's a shorter path to adjacentNode, update adjacentNode cost and prec
                if (adjacentNode.cost() == NULL || currentNode.cost() + edgeWeight < adjacentNode.cost()) {
                    adjacentNode.updateCost(currentNode.cost() + edgeWeight);
                    adjacentNode.setPrec(currentNode);
                }
                // Add neighbors to unsettled
                if (!unsettledNodes.includes(adjacentNode)) {
                    unsettledNodes.add(adjacentNode);
                }
            }
        }
        settledNodes.add(currentNode);
    }
    return getShortestPath(source, goal)
}

// TEST!

Graph g = new Graph();

Node nodeA = g.createNode("A");
Node nodeB = g.createNode("B");
Node nodeC = g.createNode("C");
Node nodeD = g.createNode("D"); 
Node nodeE = g.createNode("E");
Node nodeF = g.createNode("F");

g.addEdge(nodeA, nodeB, 10.0);
g.addEdge(nodeA, nodeC, 15.0);

g.addEdge(nodeB, nodeD, 12.0);
g.addEdge(nodeB, nodeF, 15.0);

g.addEdge(nodeC, nodeE 10.0);

g.addEdge(nodeD, nodeE, 2.0);
g.addEdge(nodeD, nodeF, 1.0);

g.addEdge(nodeF, nodeE, 5.0);

NodeList path = dijkstra(g, nodeA);

// Print data of each node (start to finish) for testing
for (Node n in path) {
    print(n.data());
}
*/

int main() {
    return 0;
}